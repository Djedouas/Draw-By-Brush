# -*- coding: utf-8 -*-
"""
/***************************************************************************
 Brush
                                 A QGIS plugin
 This plugin provides a tool for drawing polygons like with a brush in photoshop and GIMP
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                              -------------------
        begin                : 2023-02-18
        git sha              : $Format:%H$
        copyright            : (C) 2023 by Joseph Burkhart
        email                : josephburkhart.public@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""
from __future__ import print_function
from builtins import str
from builtins import range

from qgis.gui import QgsMapTool, QgsRubberBand, QgsMapToolEmitPoint, \
    QgsProjectionSelectionDialog
from qgis.core import QgsWkbTypes, QgsPointXY, QgsPoint, QgsGeometry, \
    QgsRenderContext, QgsLineString, QgsCoordinateTransform, QgsProject

from qgis.PyQt.QtCore import Qt, QCoreApplication, pyqtSignal, QPoint
from qgis.PyQt.QtWidgets import QDialog, QLineEdit, QDialogButtonBox, \
    QGridLayout, QLabel, QGroupBox, QVBoxLayout, QComboBox, QPushButton, \
    QInputDialog, QApplication
from qgis.PyQt.QtGui import QDoubleValidator, QIntValidator, QKeySequence, \
    QPixmap, QCursor, QPainter, QColor

from math import sqrt, pi, cos, sin

from PyQt5.QtGui import QGuiApplication

# Initialize Qt resources from file resources.py
from .resources import *

class BrushTool(QgsMapTool):
    """
    Brush drawing tool.
    Patterned off of `drawtools.py` from the qdraw plugin.
    """
    # Make signals for movement and end of selection and end of drawing
    selectionDone = pyqtSignal()
    move = pyqtSignal()
    rbFinished = pyqtSignal(QgsGeometry)    # from BeePen

    def __init__(self, iface):
        QgsMapTool.__init__(self, iface.mapCanvas())

        # Save references to QGIS interface and current active layer
        self.canvas = iface.mapCanvas()
        self.iface = iface
        self.active_layer = iface.activeLayer()
        
        # Set reprojection flag if active_layer has different crs from map canvas
        self.reproject_necessary = False
        if self.active_layer != None:
            if self.canvas.project().crs().authid() != self.active_layer.sourceCrs().authid():
                self.reproject_necessary = True
                self.t = QgsCoordinateTransform(
                    self.canvas.project().crs(),
                    self.active_layer.sourceCrs(),
                    QgsProject.instance()
                )
        
        # Configure Rubber Band for Drawing
        self.rb = QgsRubberBand(self.canvas, QgsWkbTypes.PolygonGeometry)
        self.rb.setWidth(1)

        # Set default brush parameters
        self.brush_radius = 40
        self.brush_points = 64

        self.mouse_state = 'free'

        # Set default tool colors
        self.draw_color = QColor(0,0,255,127)    # transparent blue
        self.erase_color = QColor(255,0,0,127)   # transparent red

        self.reset()
        return None

    def activate(self):
        """Run when tool is activated"""        #TODO: wrap this into __init__?
        self.make_cursor(self.brush_radius)

    def make_cursor(self, radius):
        """Sets the cursor to be a red circle scaled to radius in px"""
        # Set cursor shape and size
        brush_pixmap = QPixmap(':/plugins/brush/resources/redcircle_500x500.png')
        scaled_pixmap = brush_pixmap.scaled(radius*2,radius*2)
        brush_cursor=QCursor(scaled_pixmap)
        self.canvas.setCursor(brush_cursor)

    def wheelEvent(self, event):
        """If shift is pressed, rescale brush radius and redraw the cursor"""
        modifiers = QApplication.keyboardModifiers()
        if modifiers == Qt.ShiftModifier:
            event.accept()
            d = event.angleDelta().y()
            self.brush_radius *= 1 + d/1000
            self.make_cursor(int(self.brush_radius))

    def reset(self):
        self.startPoint = self.endPoint = None
        self.isEmittingPoint = False
        self.rb.reset(True)	 # true, its a polygon

    def circle_around_point(self, center, radius=0, num_points=0, map_units=False):
        """
        Creates a circular QgsGeometry centered on a point with the given 
        radius and num_points

        :type center: qgis.core.QgsPoint
        :param center: canvas point, in layer crs
        :type radius: float
        :param radius: cicle radius, considered to be in layer units
        :type num_points: int
        :param num_points: number of vertices
        :type map_units: bool
        :param map_units: whether the radius should be considered in map units
        :return: QgsGeometry of type QGis.Polygon

        Adapted from https://gis.stackexchange.com/a/69792
        """
        if not radius:
            radius = self.brush_radius #default brush radius
        
        if not map_units:
            context = QgsRenderContext().fromMapSettings(self.canvas.mapSettings())
            # scale factor is px / mm; as mm (converted to map pixels, then to map units)
            radius *= context.mapToPixel().mapUnitsPerPixel()
        if not num_points:
            num_points = self.brush_points

        points = []

        for i in range(num_points-1):
            theta = i * (2.0 * pi / (num_points-1))
            p = QgsPointXY(center.x() + radius * cos(theta),
                         center.y() + radius * sin(theta))
            points.append(p)
        
        return QgsGeometry.fromPolygonXY([points])

    def canvasPressEvent(self, event):
        """
        The following needs to happen:
          - apply the current brush to the rubber band
          - start tracking mouse movement

        """
        # Update reference to active layer
        self.active_layer = self.iface.activeLayer()
        if self.active_layer != None: 
            if self.canvas.project().crs().authid() != self.active_layer.sourceCrs().authid():
                self.reproject_necessary = True
                self.t = QgsCoordinateTransform(
                    self.canvas.project().crs(),
                    self.active_layer.sourceCrs(),
                    QgsProject.instance()
                )

        # Set status and color
        if event.button() == Qt.LeftButton:
            self.mouse_state = 'drawing_with_brush'
            self.rb.setColor(self.draw_color)
        
        elif event.button() == Qt.RightButton:
            self.mouse_state = 'erasing_with_brush'
            self.rb.setColor(self.erase_color)
        
        # Create initial geometry
        point = self.toMapCoordinates(event.pos())
        self.rb.reset(QgsWkbTypes.PolygonGeometry) # TODO: come back
        self.rb.setToGeometry(self.circle_around_point(point), None) #changed

        # Create previous point tracker (used in canvasMoveEvent below)
        self.prev_point = point

    def canvasMoveEvent(self, event):
        """
        The following needs to happen:
          - track how far the mouse has moved since canvasPressEvent
          - once a threshold value is reached, apply current brush to rubber
            band and merge with existing rubber band
            - note: the threshold value should simply be 1-99% of the brush's
              current diameter
        """
        layer = self.active_layer

        if self.mouse_state in ('drawing_with_brush','erasing_with_brush'):
            # Get current mouse location
            point = self.toMapCoordinates(event.pos())
            
            # Calculate line from previous mouse location
            mouse_move_line = QgsLineString([self.prev_point, point])

            # Calculate buffer distance (could be moved to canvasPressEvent)
            # scale factor is px / mm; as mm (converted to map pixels, then to map units)
            context = QgsRenderContext().fromMapSettings(self.canvas.mapSettings())
            radius = self.brush_radius
            radius *= context.mapToPixel().mapUnitsPerPixel()

            # Calculate new geometry
            current_geom = QgsGeometry(mouse_move_line).buffer(radius, self.brush_points)
            previous_geom = self.rb.asGeometry()

            # Set new rubberband geometry
            self.rb.setToGeometry(previous_geom.combine(current_geom), None)

            # Set previous point tracker to current point
            self.prev_point = point

    def canvasReleaseEvent(self, event):
        """
        The following needs to happen:
          - check to see if rubber band intersects with any of the active feature
          - if so, add...
        """
        layer = self.active_layer
        geom = self.rb.asGeometry()
        # Reproject the rubberband geometry if necessary
        if self.reproject_necessary == True:
            new_geom = QgsGeometry(geom) #have to clone before transforming
            new_geom.transform(self.t)
        else:
            new_geom = geom

        # Simplify the rubberband geometry
        # tolerance value is calculated based on brush_radius and brush_points
        # scale factor is px / mm; as mm (converted to map pixels, then to map units)
        # TODO: move this calculation to __init__ above (but have to account
        #       for selecting a new layer with a different CRS)
        context = QgsRenderContext().fromMapSettings(self.canvas.mapSettings())
        radius = self.brush_radius
        radius *= context.mapToPixel().mapUnitsPerPixel()

        tolerance = (2*pi*radius)/(8*self.brush_points)

        new_geom.simplify(tolerance)
        
        # Emit final geometry
        self.rbFinished.emit(new_geom)

        # reset rubberband and refresh the canvas
        self.rb.reset()
        self.canvas.refresh()

        self.mouse_state = 'free'

    def reset(self):
        self.status = 0
        self.rb.reset(True)

    def deactivate(self):
        self.rb.reset(True)
        QgsMapTool.deactivate(self)